### 바이너리 인덱스 트리
---

- 2진법 인덱스 구조를 활용해 **''구간 합'' 문제를 효과적으로 해결해 줄 수 있는 자료구조**다.

- **펜윅 트리(Fenwick Tree)**라고도 한다.

- **세그먼트 트리의 한 종류**로 구현이 매우 간단하고 더 빠르고 효율적으로 동작한다.

- **비트(bit) 연산**을 활용하여 보다 직관적인 구조를 가지고 있어 이해하기에도 쉽다.



##### ※특정한 숫자의 마지막 비트

---

예를 들어 **7**이라는 숫자가 있을 때, 이를 비트 형태로 표현하면 다음과 같---다.

- 7: 00000000 00000000 00000000 00000111

다만 **-7**을 비트 형태로 표현할 대는 컴퓨터는 내부적으로 2의 보수 형식을 사용하고 있으므로, 1의 보수를 취한 뒤에 1을 더하면 된다.

- -7: 11111111 11111111 11111111 11111001

결과적으로 컴퓨터 내부에서 특정한 숫자의 음수를 표현할 때는 모든 비트가 0에서 1로, 1에서 0으로 바뀐 뒤에 1이 더해지게 된다. 이러한 특성 때문에 0이 아닌 <u>특정한 숫자 K의 가장 마지막 비트를 구하고자 할 때는 **K & K-** 를 수행하면 된다</u>. 이는 비트 연산이라서 빠르고 직관적이라는 특징이 있다.





##### ※마지막 비트를 이용해 트리 구조 만들기

---

인덱스가 1부터 16까지 있다고 했을 때 각 숫자의 **마지막 비트**를 '**내가 저장하고 있는 값을의 개수**'라고 생각하면 다음과 같은 트리 구조가 생성된다.

![image-20220117160248272](assets/binary%20index%20tree/image-20220117160248272.png)

예를 들어, 인덱스 8의 마지막 비트는 8이기 때문에 1~8까지의 모든 인덱스 값을 저장하고 있는 것이다. 인덱스 12는 마지막 비트가 4이기 때문에 9~12까지의 인덱스의 값을 저장하고 있는 것이다. 이런 식으로 마치 트리 구조처럼 인식할 수 있다.



##### ※특정 값 변경

---

특정 값을 변경하고자 할 때, 해당 값을 포함하고 있는 모든 구간들의 값이 변경되어야 한다. 이렇게 값을 변경할 때는 '**마지막 비트'만큼 구간을 넘어가면 된다**. 예를 들어 인덱스 3의 값을 변경하고자 할때,

![image-20220117161100801](assets/binary%20index%20tree/image-20220117161100801.png)

tree[3], tree[4], tree[8], tree[16]의 값이 갱신되는 것을 알 수 있다. 따라서 갱신되는 값들이 많아봤자 5개라는 것을 알 수 있다. 그림과 같이 위쪽으로 이동하며 갱신한다고 했을 때 세로로 5칸만 이동하면 되는 것이다. 그래서 결과적으로 시간 복잡도를 고려했을 때 하나의 값을 갱신하는 데에 드는 시간은 **O(*log*N)** 이다. '마지막 비트'만큼 지속적으로 이동하면 된다. 3 -> 4 -> 8 -> 16 순서대로 tree[] 배열을 갱신했는데 이것은 3의 마지막 비트는 1**,** 4의 마지막 비트는 4**,** 8의 마지막 비트는 8이기 때문이다. 이를 비트 형태로 표현하면 0011 -> 0100 -> 1000 -> 10000가 된다.



##### ※1부터 N까지의 합 구하기

---

특정 구간의 합을 구하고자 할 때는 1부터 N까지의 합을 구하는 방식을 이용해 구현한다. 이 때는 값을 변경할 때와는 반대로 **'마지막 비트'만큼 구간을 앞으로 가며 구하면 된다**. 예를 들어 1부터 11까지의 합을 구한다고 할 때, tree[11], tree[10], tree[8]의 세 가지의 값만 구하면 된다.

![image-20220117161821198](assets/binary%20index%20tree/image-20220117161821198.png)



구간의 합을 구하는 함수의 시간 복잡도는 구간 값 변경과 마찬가지로 **O(*log*N)** 이다. 따라서 실제로 K부터 L까지의 구간의 합을 구한다고 했을 때 sum(K)과 sum(L)의 차이가 구간의 합이 되며 단순히 sum() 함수를 두 번 실행하는 것이므로 여전히 시간 복잡도는 O(*log*N)이다.

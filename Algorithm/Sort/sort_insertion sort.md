## 삽입 정렬

- 처리되지 않은 데이터를 하나씩 골라 **적절한 위치에 삽입**함

- 선택 정렬에 비해 구현 난이도는 높지만, 속도는 더 빠름.



---

### 삽입 정렬 동작 예시



![image-20220126161016945](assets/sort_insertion%20sort/image-20220126161016945.png)

**[step 0]** 첫 번째 데이터 '7'은 그 자체로 정렬이 되어 있다고 판단. 두 번째 데이터인 '5'가 어떤 위치로 들어갈지 판단함**. '7'의 왼쪽으로 들어가거나 오른쪽으로 들어가거나** 두 경우만 존재한다. 기본적으로 오름차순 정렬을 한다고 가정하여 왼쪽 데이터와 비교해서 작다면 왼쪽으로 들어가게 한다.



![image-20220126161226712](assets/sort_insertion%20sort/image-20220126161226712.png)

**[step 1]** 이어서 '9'가 어디에 들어갈 지 결정함. 두 데이터보다 크기 때문에 위치 안바꿈.





![image-20220126161322894](assets/sort_insertion%20sort/image-20220126161322894.png)

**[step 2]** 이어서 '0'이 어떤 위치로 들어갈지 판단.

...

...

...

![image-20220126161410909](assets/sort_insertion%20sort/image-20220126161410909.png)

이러한 과정을 반복하면 정렬이 완료됨.

---





### 삽입 정렬 소스코드

```python
array = [7,5,9,0,3,1,6,2,4,8]

for i in range(1,len(array)):
    for j in range(i,0,-1): # 인덱스 i부터 1까지 1씩 감소하며 반복
        if array[j] < array[j-1]:   # 한 칸씩 왼쪽으로 이동
            array[j],array[j-1] = array[j-1],array[j]
        else: # 자기보다 작은 데이터를 만나면 그 위치에 멈춤
            break
print(array)
>>>
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

---





### 삽입 정렬의 시간 복잡도

- O(N^2) 이며, 선택 정렬과 마찬가지로 반복문이 두 번 중첩되어 사용된다.
- 삽입 정렬은 **현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작**한다.
- 최선의 경우 O(N)의 시간 복잡도를 가진다.